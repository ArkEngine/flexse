看sphinx的文档
(1) 为什么要做这个东东
-1- 搜索产品内部需要
    我们的相关搜索和搜索建议，本质上还是倒排结构。
-2- 搜索院对其他部门的技术支持
    云城搜索/C2C搜索/积分商城搜索。。

(2) 架构愿景和应用前景
-1- 一张图，表示云搜索，叙述工作流程，小数据+大数据量扩展
-2- 应用前景，框架的应用 + 插件使用

(3) 特性
性能方面
-0- 实时索引
-1- 快速建库
-2- 快速查询
-3- 超大数据
功能方面
-4- 算法强大
-5- 功能全配
-6- 灵活配置
数据恢复
-7- 崩溃恢复
架构远景
-8- 云搜索化
二次开发
-9- 支持插件

(1) 倒排索引
-1- index_group = mem_indexer + disk_indexer
-2- mem_indexer = postinglist + creat_sign
    #1# postinglist = (hash-bucket) + (headlist) + memblocks
-3- disk_indexer = 二级索引 + [1级索引cache] + fileblock + diskv
索引管理逻辑
-1- mem/disk的时间节点
-2- dump逻辑
-3- 修改和删除(bitmap+idmap)

(2) 文档属性
-1- bitlist + structmask

(3) 文档详细
-1- detaildb = fileblock + diskv

服务搭建
(1) 线程组成
-1- equeue + query_threads
-2- update_thread
-3- day_merger_thread
-4- his_merger_thread
-5- ontime_thread
(2) 通信协议
-1- xhead + json

===============================================================
(1) 概述
flexse目前是一个搜索的框架，提供了搜索引擎中数据的存储和访问，特别实现了倒排数据的实时索引。
-1- 倒排索引原理
    倒排索引抽象成数据结构，可以理解为map<string, vector<index_t>>，string就是分词形成的每
    个term，而vector<index_t>就是含有这个term的各个文档ID列表，index_t就是描述这个term属性
    的结构，index_t中必须含有一个ID。通过flexse/utils/indexer/index_group/index_group.cpp
    中的get_posting_list方法，可以获得一个term对应的postinglist，如果内存不够存储，则返回
    最新的内存大小的postinglist，失败返回-1。postinglist按照ID降序排列。
-2- 如何做到实时索引和实时更新(插件开发者不需要知道)
    每个文档都会有个外部ID和内部ID，外部ID都是连续的，内部ID也是连续的，一个外部ID对应于一
    个最新的内部ID。通过flexse/utils/idmap来管理内部和外部ID，当插入或更新一个文档时，根据
    该文档的外部ID，来检查是否已经为其分配过内部ID，如果不存在，则内部ID自增后，为其分配一
    个内部ID；如果已经为其分配过内部ID，则把内部ID对应的bitmap对应位置设置为1，且为其分配一
    个新内部ID。
    这样，当失效的内部ID经过mod_bitset过滤时，就能去掉已经失效的文档了。
    举个例子:
    文档1含有term: a/b/c, 外部ID为1，插入后，为其分配内部ID为1；
    文档1更新，term更新为: a/d/e，更新后，为其分配一个新的内部ID为2，同时把mod_bitset中，内
    部ID为1的位置设置为1。当我们搜索a时，可以得到内部ID为1和2的文档，经过mod_bitset过滤后，
    文档2得以保留，去掉了失效的文档1。
-3- 如何访问文档属性数据
    文档属性数据存储于文件中，以mmap的方式load到内存中，以数组的方式访问，使用内部ID作为偏移
    以structmask的机制来访问数据，structmask的原理见这个wiki
(2) 更新
-1- 如何更新倒排索引postinglist
    输入: xhead+json-string，有固定的格式，解析过程详见代码flexse/plugin/flexse/
    输出: xhead.
    测试工具: flexse/flexse/test/update.py，与配置文件flexse/flexse/conf/plugin.config.json
    相互对应，目前支持分词/前缀/数组前缀这三种方式
    postinglist根据term形成的机制分为两种类型，NLP分词和前缀生成，视频搜索视需求来选择这两
    个类型
    a) NLP分词形成的term，在flexse/utils/nlp_processor/nlp_processor.cpp中可以设置分词形成
       的各个term的描述信息，如tf/idf/offset/title_hit/tag_hit等等，需要注意的是，视频全网
       搜索的offset计算，建议使用title即可，因为视频的描述信息在各大网站上看，基本都是空的
    b) 前缀生成的term，比如"TAG^搞笑"等等，term的描述一般都为默认值
-2- 如何更新文档属性document-attribute
    这部分代码已经完成，原理是根据配置中，迭代STRUCTMASK/document_attr中各个字段，把其中的
    key<->value存入vector中，update_thread.cpp中对外部的doc_id进行内部ID分配，然后更新内部
    ID对应的document_attribute属性
(3) 查询
    输入为xhead+json-string，有固定的格式，解析过程详见代码flexse/plugin/flexse/
    输出是xhead+struct数组(不使用json或其他序列化方案是为了性能考虑)，返回值表示struct数组
    的sizeof大小
    查询操作在flexse/plugin/flexse/flexse_plugin.cpp中实现
    测试工具: flexse/flexse/test/qquery.py，与配置文件flexse/flexse/conf/plugin.config.json
    相互对应，目前支持分词/前缀/数组前缀这三种方式
    查询的步骤一般可以分为
    a) 根据termlist，读取对应的postinglist。
    b) 把一组postinglist交给归并算法进行合并，目前已经支持按照term的权重进行归并(algo.cpp)。
    c) 对归并结果postinglist进行过滤，目前已经支持按照某个字段执行(等于/小于/大于/大于小于
        /集合这5种过滤)(algo.cpp)
    d) 对过滤结果postinglist进行调权，目前已经支持按照某个字段执行(等于/小于/大于/大于小于
        /集合这5种调权)(algo.cpp)
    e) 按照权重返回top2000的结果，把每个ID的document-attribute带上















